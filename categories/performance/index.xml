<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>performance on Paulo Oliveira</title><link>https://blog.pauloliveira.dev/categories/performance/</link><description>Paulo Oliveira (performance)</description><generator>Hugo -- gohugo.io</generator><language>pt-BR</language><lastBuildDate>Thu, 20 May 2021 00:59:51 +0100</lastBuildDate><atom:link href="https://blog.pauloliveira.dev/categories/performance/index.xml" rel="self" type="application/rss+xml"/><item><title>Async/Await - Pequenas dicas ;)</title><link>https://blog.pauloliveira.dev/post/2021-05-17-async-await-dicas-que-aprendi/</link><pubDate>Thu, 20 May 2021 00:59:51 +0100</pubDate><guid>https://blog.pauloliveira.dev/post/2021-05-17-async-await-dicas-que-aprendi/</guid><description>&lt;p>OlÃ¡ novamente, sei que passou muito tempo atÃ© chegarmos nesse novo post, tive contra-tempos, falta de vontade de continuar, e comecei a fazer algo que nÃ£o fazia que era guardar em algum lugar o que aprendi para partilhar aqui. Enfim, vamos a isso ðŸ¤“&lt;/p>
&lt;p>Estive a fazer um curso sobre cÃ³digo assÃ­ncrono em .NET/C# &lt;a href="https://asyncexpert.com">Async Experts&lt;/a>, e acho que tem conteÃºdo suficiente para render alguns posts, entÃ£o comecei a fazer uma lista para partilhar aqui, agora vou deixar uma dica que vocÃª pode jÃ¡ saber ou talvez nunca tenha notado.&lt;/p>
&lt;h2 id="exceptions">Exceptions&lt;/h2>
&lt;p>Observe o exemplo abaixo por um minuto e tente identificar se existe algo &amp;ldquo;mal&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt; Method_A_Async(&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span>.IsNullOrEmpty(&lt;span style="color:#66d9ef">value&lt;/span>))
{
&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentException();
}
&lt;span style="color:#66d9ef">var&lt;/span> response = &lt;span style="color:#66d9ef">await&lt;/span> httpClient.GetAsync(&lt;span style="color:#66d9ef">value&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> response != &lt;span style="color:#66d9ef">null&lt;/span>;
}
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task A_MethodA_Async()
{
&lt;span style="color:#66d9ef">var&lt;/span> x = &lt;span style="color:#66d9ef">await&lt;/span> Method_A_Async(&lt;span style="color:#e6db74">&amp;#34;x&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task B_MethodA_Async()
{
&lt;span style="color:#66d9ef">var&lt;/span> x = &lt;span style="color:#66d9ef">await&lt;/span> Method_A_Async(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>O cÃ³digo nÃ£o tem nenhum problema, o mÃ©todo &lt;code>A_MethodA_Async&lt;/code> irÃ¡ ser executado sem gerar exceÃ§Ãµes, enquanto o mÃ©todo &lt;code>B_MethodA_Async&lt;/code> lanÃ§arÃ¡ uma exceÃ§Ã£o do tipo &lt;code>ArgumentException&lt;/code>. VocÃª pode jÃ¡ ter escrito mÃ©todos dessa forma e vÃ£o funcionar, mas se pensarmos em como mÃ©todos assÃ­ncronos sÃ£o executados estamos a utilizar um pouco mal os recursos quando o mÃ©todo &lt;code>B_MethodA_Async&lt;/code> Ã© executado.&lt;/p>
&lt;p>Quando fazemos &lt;code>await&lt;/code> para computar o valor de uma &lt;code>Task&lt;/code> estamos a escalar a execuÃ§Ã£o da &lt;code>Task&lt;/code> para o &lt;code>ThreadPool&lt;/code>, pois bem, no exemplo acima existem dois caminhos para nosso cÃ³digo executar: primeiro quando passar um valor que Ã© vazio ou nulo, o segundo Ã© quando passamos um valor vÃ¡lido e temos uma nova chama assÃ­ncrona. Isso significa que podemos (ou nÃ£o) estar a utilizar mais de uma thread para processar cÃ³digo que poderia ser sÃ­ncrono, vamos reescrever o cÃ³digo do mÃ©todo &lt;code>Method_A_Async&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#66d9ef">public&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt; Method_B_Async(&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span>.IsNullOrEmpty(&lt;span style="color:#66d9ef">value&lt;/span>))
{
&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentException();
}
&lt;span style="color:#66d9ef">return&lt;/span> Method_B_InternalAsync(&lt;span style="color:#66d9ef">value&lt;/span>);
}
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt; Method_B_InternalAsync(&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)
{
&lt;span style="color:#66d9ef">var&lt;/span> response = &lt;span style="color:#66d9ef">await&lt;/span> httpClient.GetAsync(&lt;span style="color:#66d9ef">value&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> response != &lt;span style="color:#66d9ef">null&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Primeiro notem que removi o &lt;code>async&lt;/code> da assinatura do mÃ©todo, nÃ£o estamos mais a utilizar o &lt;code>await&lt;/code> para nenhuma chamada, entÃ£o isso torna &lt;code>Method_B_Async&lt;/code> um mÃ©todo sÃ­ncrono. TambÃ©m criei um novo mÃ©todo &lt;code>Method_B_InternalAsync&lt;/code> (usando &lt;code>async&lt;/code> na assinatura) que nÃ£o tem mais as validaÃ§Ãµes necessÃ¡rias para os parÃ¢metros (feitas no mÃ©todo &lt;code>Method_B_Async&lt;/code>), isso Ã© chamado de &amp;ldquo;async eliding&amp;rdquo; e a traduÃ§Ã£o pode ficar um pouco estranha mas Ã© algo como &lt;em>&amp;ldquo;suprimir/omitir o assÃ­ncrono&amp;rdquo;&lt;/em>.&lt;/p>
&lt;p>Abaixo podemos ver melhor o que significa adicionar o &lt;code>async&lt;/code> na assinatura do mÃ©todo:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#a6e22e">[AsyncStateMachine(typeof(&amp;lt;Method_A_Async&amp;gt;d__1))]&lt;/span>
&lt;span style="color:#a6e22e">[DebuggerStepThrough]&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt; Method_A_Async(&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)
{
&amp;lt;Method_A_Async&amp;gt;d__1 stateMachine = &lt;span style="color:#66d9ef">new&lt;/span> &amp;lt;Method_A_Async&amp;gt;d__1();
stateMachine.&amp;lt;&amp;gt;t__builder = AsyncTaskMethodBuilder&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt;.Create();
stateMachine.&amp;lt;&amp;gt;&lt;span style="color:#ae81ff">4&lt;/span>__this = &lt;span style="color:#66d9ef">this&lt;/span>;
stateMachine.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#66d9ef">value&lt;/span>;
stateMachine.&amp;lt;&amp;gt;&lt;span style="color:#ae81ff">1&lt;/span>__state = -&lt;span style="color:#ae81ff">1&lt;/span>;
stateMachine.&amp;lt;&amp;gt;t__builder.Start(&lt;span style="color:#66d9ef">ref&lt;/span> stateMachine);
&lt;span style="color:#66d9ef">return&lt;/span> stateMachine.&amp;lt;&amp;gt;t__builder.Task;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>E sem &lt;code>async&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="color:#66d9ef">public&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt; Method_B_Async(&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span>.IsNullOrEmpty(&lt;span style="color:#66d9ef">value&lt;/span>))
{
&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArgumentException();
}
&lt;span style="color:#66d9ef">return&lt;/span> Method_B_InternalAsync(&lt;span style="color:#66d9ef">value&lt;/span>);
}
&lt;span style="color:#a6e22e">
&lt;/span>&lt;span style="color:#a6e22e">[AsyncStateMachine(typeof(&amp;lt;Method_B_InternalAsync&amp;gt;d__2))]&lt;/span>
&lt;span style="color:#a6e22e">[DebuggerStepThrough]&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> Task&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt; Method_B_InternalAsync(&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>)
{
&amp;lt;Method_B_InternalAsync&amp;gt;d__2 stateMachine = &lt;span style="color:#66d9ef">new&lt;/span> &amp;lt;Method_B_InternalAsync&amp;gt;d__2();
stateMachine.&amp;lt;&amp;gt;t__builder = AsyncTaskMethodBuilder&amp;lt;&lt;span style="color:#66d9ef">bool&lt;/span>&amp;gt;.Create();
stateMachine.&amp;lt;&amp;gt;&lt;span style="color:#ae81ff">4&lt;/span>__this = &lt;span style="color:#66d9ef">this&lt;/span>;
stateMachine.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#66d9ef">value&lt;/span>;
stateMachine.&amp;lt;&amp;gt;&lt;span style="color:#ae81ff">1&lt;/span>__state = -&lt;span style="color:#ae81ff">1&lt;/span>;
stateMachine.&amp;lt;&amp;gt;t__builder.Start(&lt;span style="color:#66d9ef">ref&lt;/span> stateMachine);
&lt;span style="color:#66d9ef">return&lt;/span> stateMachine.&amp;lt;&amp;gt;t__builder.Task;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Um mÃ¡quina de estados Ã© criada para a execuÃ§Ã£o do mÃ©todo assÃ­ncrono e a validaÃ§Ã£o dos parÃ¢metros serÃ¡ feito dentro dessa mÃ¡quina de estados. Enquanto se utilizarmos a outra abordagem, conseguimos manter as validaÃ§Ãµes que nÃ£o dependem de mÃ©todos assÃ­ncronos fora do fluxo assÃ­ncrono de execuÃ§Ã£o.&lt;/p>
&lt;p>Pode parecer um detalhe mas evitar a mÃ¡quina de estados (no nosso exemplo quando vamos parar a execuÃ§Ã£o do mÃ©todo por causa de uma validaÃ§Ã£o/exceÃ§Ã£o) alÃ©m de poder melhorar o uso de mais threads na execuÃ§Ã£o tambÃ©m evita a alocaÃ§Ã£o de objetos para gerir o cÃ³digo assÃ­ncrono. SÃ£o otimizaÃ§Ãµes que em &lt;em>hot-paths&lt;/em> (trechos muito executados na aplicaÃ§Ã£o) podem gerar ganhos positivos e performance ðŸ˜‰.&lt;/p></description></item></channel></rss>